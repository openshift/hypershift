package omoperator

import (
	"context"
	"fmt"
	"os"

	"github.com/spf13/cobra"
	"go.uber.org/zap/zapcore"

	"github.com/openshift/library-go/pkg/operator/resource/resourceread"

	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/log/zap"
	"sigs.k8s.io/yaml"
)

func NewTransformDeploymentCommand() *cobra.Command {
	transformer := &oauthDeploymentTransformer{}
	cmd := &cobra.Command{
		Use:   "transform-deployment",
		Short: "Transform the oauth-server deployment generated on standalone to hcp",
		RunE: func(cmd *cobra.Command, args []string) error {
			if err := transformer.Validate(); err != nil {
				return err
			}
			if err := transformer.Run(ctrl.SetupSignalHandler()); err != nil {
				ctrl.Log.Error(err, "Error running Oauth Deployment Transformer")
				os.Exit(1)
			}
			return nil
		},
	}

	flags := cmd.Flags()
	flags.StringVar(&transformer.SourceDeploymentPath, "source-deployment", transformer.SourceDeploymentPath, "path to the oauth-server deployment generated by the auth-operator")
	flags.StringVar(&transformer.TargetDeploymentPath, "target-deployment", transformer.SourceDeploymentPath, "path to the oauth-server deployment used on HCP")
	flags.StringVar(&transformer.DestinationDeploymentPath, "destination-deployment", transformer.SourceDeploymentPath, "path under which the destination/output oauth-server deployment is written")

	return cmd
}

type oauthDeploymentTransformer struct {
	SourceDeploymentPath      string
	TargetDeploymentPath      string
	DestinationDeploymentPath string
}

func (t *oauthDeploymentTransformer) Validate() error {
	if len(t.SourceDeploymentPath) == 0 {
		return fmt.Errorf("oauth-server deployment path must be specified")
	}
	if len(t.TargetDeploymentPath) == 0 {
		return fmt.Errorf("oauth-server deployment used on HCP must be specified")
	}
	if len(t.DestinationDeploymentPath) == 0 {
		t.DestinationDeploymentPath = "destination-oauth-server-deployment.yaml"
	}
	return nil
}

func (t *oauthDeploymentTransformer) Run(ctx context.Context) error {
	ctrl.SetLogger(zap.New(zap.JSONEncoder(func(o *zapcore.EncoderConfig) {
		o.EncodeTime = zapcore.RFC3339TimeEncoder
	})))
	ctrl.Log.Info("Starting Oauth Deployment Transformer")
	return t.runInternal(ctx)
}

func (t *oauthDeploymentTransformer) runInternal(ctx context.Context) error {
	standaloneOauthDeployment, err := readOauthServerDeployment(t.SourceDeploymentPath)
	if err != nil {
		return err
	}
	hcpOauthDeployment, err := readOauthServerDeployment(t.TargetDeploymentPath)
	if err != nil {
		return err
	}

	destinationOauthServerDeployment := &appsv1.Deployment{}
	destinationOauthServerDeployment = standaloneOauthDeployment.DeepCopy()

	// TODO: store org standaloneDeployment in annotation

	removeSpecTemplateSpecAffinityFromDeployment(destinationOauthServerDeployment)
	removeSpecTemplateSpecNodeSelectorFromDeployment(destinationOauthServerDeployment)
	removeSpecTemplateSpecPriorityClassFromDeployment(destinationOauthServerDeployment)
	removeSpecTemplateSpecServiceAccountNameFromDeployment(destinationOauthServerDeployment)
	removeSpecTemplateSpecTolerationsFromDeployment(destinationOauthServerDeployment)

	// TODO: remove some annotations/labels like:
	// - openshift.io/required-scc: privileged ?
	// - target.workload.openshift.io/management: '{"effect": "PreferredDuringScheduling"}' ?

	if err = transformOauthServerContainerToMatchHCP(destinationOauthServerDeployment, hcpOauthDeployment); err != nil {
		return err
	}

	copySpecRevisionHistoryLimitFromHCPOauthDeployment(hcpOauthDeployment, destinationOauthServerDeployment)
	copySpecStrategyFromHCPOauthDeployment(hcpOauthDeployment, destinationOauthServerDeployment)

	ctrl.Log.Info("Writing Destination OAuth Deployment", "path", t.DestinationDeploymentPath)
	return writeDeploymentOnDisk(t.DestinationDeploymentPath, destinationOauthServerDeployment)
}

func removeSpecTemplateSpecAffinityFromDeployment(deployment *appsv1.Deployment) {
	deployment.Spec.Template.Spec.Affinity = nil
}

func removeSpecTemplateSpecNodeSelectorFromDeployment(deployment *appsv1.Deployment) {
	deployment.Spec.Template.Spec.NodeSelector = nil
}

func removeSpecTemplateSpecPriorityClassFromDeployment(deployment *appsv1.Deployment) {
	deployment.Spec.Template.Spec.PriorityClassName = ""
}

func removeSpecTemplateSpecServiceAccountNameFromDeployment(deployment *appsv1.Deployment) {
	deployment.Spec.Template.Spec.ServiceAccountName = ""
}

func removeSpecTemplateSpecTolerationsFromDeployment(deployment *appsv1.Deployment) {
	deployment.Spec.Template.Spec.Tolerations = nil
}

func transformOauthServerContainerToMatchHCP(standaloneOauthDeployment, hcpOauthDeployment *appsv1.Deployment) error {
	standaloneOauthServerContainer, err := readNamedContainerFromDeployment(standaloneOauthDeployment, "oauth-openshift")
	if err != nil {
		return err
	}
	hcpOauthServerContainer, err := readNamedContainerFromDeployment(hcpOauthDeployment, "oauth-openshift")
	if err != nil {
		return err
	}

	// hcp doesn't expose any ports
	standaloneOauthServerContainer.Ports = nil

	// hcp doesn't set security context
	standaloneOauthServerContainer.SecurityContext = nil

	// copy env var specified for hcp
	standaloneOauthServerContainer.Env = hcpOauthServerContainer.Env

	replaceNamedContainerFromDeployment(standaloneOauthDeployment, standaloneOauthServerContainer)

	return nil
}

func copySpecRevisionHistoryLimitFromHCPOauthDeployment(hcpDeployment, destinationDeployment *appsv1.Deployment) {
	destinationDeployment.Spec.RevisionHistoryLimit = hcpDeployment.Spec.RevisionHistoryLimit
}

func copySpecStrategyFromHCPOauthDeployment(hcpDeployment, destinationDeployement *appsv1.Deployment) {
	destinationDeployement.Spec.Strategy = hcpDeployment.Spec.Strategy
}

func readNamedContainerFromDeployment(deployment *appsv1.Deployment, containerName string) (corev1.Container, error) {
	for _, container := range deployment.Spec.Template.Spec.Containers {
		if container.Name == containerName {
			return container, nil
		}
	}
	return corev1.Container{}, fmt.Errorf("container %s not found in %s/%s deployment", containerName, deployment.Namespace, deployment.Name)
}

func replaceNamedContainerFromDeployment(deployment *appsv1.Deployment, containerToReplace corev1.Container) {
	containers := []corev1.Container{}
	for _, container := range deployment.Spec.Template.Spec.Containers {
		if container.Name == container.Name {
			containers = append(containers, containerToReplace)
			continue
		}
		containers = append(containers, container)
	}
	deployment.Spec.Template.Spec.Containers = containers
}

func writeDeploymentOnDisk(path string, destination *appsv1.Deployment) error {
	deploymentBytes, err := yaml.Marshal(destination)
	if err != nil {
		return err
	}

	return os.WriteFile(path, deploymentBytes, 0644)
}

func readOauthServerDeployment(path string) (*appsv1.Deployment, error) {
	deploymentBytes, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("read file err: %w", err)
	}

	return resourceread.ReadDeploymentV1OrDie(deploymentBytes), nil
}
