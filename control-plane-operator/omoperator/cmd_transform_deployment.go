package omoperator

import (
	"context"
	"fmt"
	"os"
	"regexp"

	"github.com/spf13/cobra"
	"go.uber.org/zap/zapcore"

	hyperv1 "github.com/openshift/hypershift/api/hypershift/v1beta1"
	"github.com/openshift/hypershift/control-plane-operator/controllers/hostedcontrolplane/common"
	"github.com/openshift/hypershift/control-plane-operator/controllers/hostedcontrolplane/imageprovider"
	"github.com/openshift/hypershift/control-plane-operator/controllers/hostedcontrolplane/v2/oauth"
	component "github.com/openshift/hypershift/support/controlplane-component"
	"github.com/openshift/hypershift/support/releaseinfo"
	"github.com/openshift/hypershift/support/util"
	"github.com/openshift/library-go/pkg/operator/resource/resourceread"

	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/client-go/tools/clientcmd"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/log/zap"
	"sigs.k8s.io/yaml"
)

func NewTransformDeploymentCommand() *cobra.Command {
	transformer := &oauthDeploymentTransformer{}
	cmd := &cobra.Command{
		Use:   "transform-deployment",
		Short: "Transform the oauth-server deployment generated on standalone to hcp",
		RunE: func(cmd *cobra.Command, args []string) error {
			if err := transformer.Validate(); err != nil {
				return err
			}
			if err := transformer.Run(ctrl.SetupSignalHandler()); err != nil {
				ctrl.Log.Error(err, "Error running Oauth Deployment Transformer")
				os.Exit(1)
			}
			return nil
		},
	}

	flags := cmd.Flags()
	flags.StringVar(&transformer.Namespace, "namespace", transformer.Namespace, "the namespace for control plane components on management cluster.")
	flags.StringVar(&transformer.HostedControlPlaneName, "hosted-control-plane", transformer.HostedControlPlaneName, "Name of the hosted control plane that owns this operator.")
	flags.StringVar(&transformer.SourceDeploymentPath, "source-deployment", transformer.SourceDeploymentPath, "path to the oauth-server deployment generated by the auth-operator")
	flags.StringVar(&transformer.TargetDeploymentPath, "target-deployment", transformer.TargetDeploymentPath, "path to the oauth-server deployment used on HCP")
	flags.StringVar(&transformer.DestinationDeploymentPath, "destination-deployment", transformer.SourceDeploymentPath, "path under which the destination/output oauth-server deployment is written")
	flags.StringVar(&transformer.ManagementClusterKubeconfigPath, "management-cluster-kubeconfig", transformer.ManagementClusterKubeconfigPath, "path to kubeconfig file for the management cluster.")

	return cmd
}

type oauthDeploymentTransformer struct {
	SourceDeploymentPath            string
	TargetDeploymentPath            string
	DestinationDeploymentPath       string
	ManagementClusterKubeconfigPath string
	HostedControlPlaneName          string
	Namespace                       string
}

func (t *oauthDeploymentTransformer) Validate() error {
	if len(t.SourceDeploymentPath) == 0 {
		return fmt.Errorf("oauth-server deployment path must be specified")
	}
	if len(t.TargetDeploymentPath) == 0 {
		return fmt.Errorf("oauth-server deployment used on HCP must be specified")
	}
	if len(t.DestinationDeploymentPath) == 0 {
		t.DestinationDeploymentPath = "destination-oauth-server-deployment.yaml"
	}
	return nil
}

func (t *oauthDeploymentTransformer) Run(ctx context.Context) error {
	ctrl.SetLogger(zap.New(zap.JSONEncoder(func(o *zapcore.EncoderConfig) {
		o.EncodeTime = zapcore.RFC3339TimeEncoder
	})))
	ctrl.Log.Info("Starting Oauth Deployment Transformer")
	return t.runInternal(ctx)
}

func (t *oauthDeploymentTransformer) runInternal(ctx context.Context) error {
	standaloneOauthDeployment, err := readOauthServerDeployment(t.SourceDeploymentPath)
	if err != nil {
		return err
	}
	hcpOauthDeployment, err := readOauthServerDeployment(t.TargetDeploymentPath)
	if err != nil {
		return err
	}

	destinationOauthServerDeployment := &appsv1.Deployment{}
	destinationOauthServerDeployment = standaloneOauthDeployment.DeepCopy()

	destinationOauthServerDeploymentNamespace := destinationOauthServerDeployment.Namespace
	destinationOauthServerDeploymentName := destinationOauthServerDeployment.Name

	// TODO: the # of replicas needs to be set by the deployment controller
	// for now, unset # of replicas, it will be set by the oauth.RenderDeployment method
	destinationOauthServerDeployment.Spec.Replicas = nil

	removeSpecTemplateSpecAffinityFromDeployment(destinationOauthServerDeployment)
	removeSpecTemplateSpecNodeSelectorFromDeployment(destinationOauthServerDeployment)
	removeSpecTemplateSpecPriorityClassFromDeployment(destinationOauthServerDeployment)
	removeSpecTemplateSpecServiceAccountNameFromDeployment(destinationOauthServerDeployment)
	removeSpecTemplateSpecTolerationsFromDeployment(destinationOauthServerDeployment)
	removeSpecTemplateSpecMetadataAnnotationFromDeployment(destinationOauthServerDeployment)
	// TODO: remove some annotations/labels like:
	// - target.workload.openshift.io/management: '{"effect": "PreferredDuringScheduling"}' ?

	if err = transformOauthServerContainerToMatchHCP(hcpOauthDeployment, destinationOauthServerDeployment); err != nil {
		return err
	}
	if err = copyAuditLogsContainerFromHCPOauthDeployment(hcpOauthDeployment, destinationOauthServerDeployment); err != nil {
		return err
	}

	copyNamespaceFromHCPOauthDeployment(hcpOauthDeployment, destinationOauthServerDeployment)
	copySpecTemplateSpecTerminationGracePeriodSecondsFromHCPOauthDeployment(hcpOauthDeployment, destinationOauthServerDeployment)

	copySpecRevisionHistoryLimitFromHCPOauthDeployment(hcpOauthDeployment, destinationOauthServerDeployment)
	copySpecStrategyFromHCPOauthDeployment(hcpOauthDeployment, destinationOauthServerDeployment)

	renameConfigMapReferenceInSpecTemplateSpecVolumesFromDeployment(destinationOauthServerDeployment, "v4-0-config-system-cliconfig", hcpNameForNamespacedStandaloneResource("openshift-authentication", "v4-0-config-system-cliconfig"))
	renameConfigMapReferenceInSpecTemplateSpecVolumesFromDeployment(destinationOauthServerDeployment, "audit", hcpNameForNamespacedStandaloneResource("openshift-authentication", "audit"))
	// v4-0-config-system-service-ca is projected from oauth-master-ca-bundle
	renameConfigMapReferenceInSpecTemplateSpecVolumesFromDeployment(destinationOauthServerDeployment, "v4-0-config-system-service-ca", "oauth-master-ca-bundle")

	renameSecretReferenceInSpecTemplateSpecVolumesFromDeployment(destinationOauthServerDeployment, "v4-0-config-system-router-certs", hcpNameForNamespacedStandaloneResource("openshift-authentication", "v4-0-config-system-router-certs"))
	renameSecretReferenceInSpecTemplateSpecVolumesFromDeployment(destinationOauthServerDeployment, "v4-0-config-system-session", hcpNameForNamespacedStandaloneResource("openshift-authentication", "v4-0-config-system-session"))
	// v4-0-config-system-serving-cer its projected from oauth-server-crt
	renameSecretReferenceInSpecTemplateSpecVolumesFromDeployment(destinationOauthServerDeployment, "v4-0-config-system-serving-cert", "oauth-server-crt")
	renameSecretReferenceInSpecTemplateSpecVolumesFromDeployment(destinationOauthServerDeployment, "v4-0-config-system-ocp-branding-template", hcpNameForNamespacedStandaloneResource("openshift-authentication", "v4-0-config-system-ocp-branding-template"))

	// rename the optional templates
	renameSecretReferenceInSpecTemplateSpecVolumesFromDeployment(destinationOauthServerDeployment, "v4-0-config-user-template-login", hcpNameForNamespacedStandaloneResource("openshift-authentication", "v4-0-config-user-template-login"))
	renameSecretReferenceInSpecTemplateSpecVolumesFromDeployment(destinationOauthServerDeployment, "v4-0-config-user-template-provider-selection", hcpNameForNamespacedStandaloneResource("openshift-authentication", "v4-0-config-user-template-provider-selection"))
	renameSecretReferenceInSpecTemplateSpecVolumesFromDeployment(destinationOauthServerDeployment, "v4-0-config-user-template-error", hcpNameForNamespacedStandaloneResource("openshift-authentication", "v4-0-config-user-template-error"))

	// TODO: v4-0-config-system-trusted-ca-bundle ?
	// TODO: add defaultMode to the volumes ?

	removeNamedVolumeFromSpecTemplateSpecVolumesFromDeployment(destinationOauthServerDeployment, "audit-dir")
	removeNamedVolumeFromSpecTemplateSpecVolumesFromDeployment(destinationOauthServerDeployment, "v4-0-config-system-router-certs")

	copyNamedSpecTemplateSpecVolumeFromHCP(hcpOauthDeployment, destinationOauthServerDeployment, "logs")
	copyNamedSpecTemplateSpecVolumeFromHCP(hcpOauthDeployment, destinationOauthServerDeployment, "kubeconfig")

	destinationOauthServerDeployment.Namespace = t.Namespace

	//
	// now apply hcp transformations
	//

	cfg, err := clientcmd.BuildConfigFromFlags("", t.ManagementClusterKubeconfigPath)
	if err != nil {
		return err
	}
	scheme := runtime.NewScheme()
	if err = hyperv1.AddToScheme(scheme); err != nil {
		return err
	}
	if err = appsv1.AddToScheme(scheme); err != nil {
		return err
	}
	if err = corev1.AddToScheme(scheme); err != nil {
		return err
	}

	managementClusterClient, err := client.New(cfg, client.Options{Scheme: scheme})
	if err != nil {
		return err
	}
	hcp := &hyperv1.HostedControlPlane{}
	if err = managementClusterClient.Get(ctx, client.ObjectKey{
		Namespace: t.Namespace,
		Name:      t.HostedControlPlaneName,
	}, hcp); err != nil {
		return err
	}
	cpContext, err := createCpContext(ctx, hcp, managementClusterClient)
	if err != nil {
		return err
	}
	destinationOauthServerDeployment, err = oauth.RenderDeployment(cpContext, destinationOauthServerDeployment)
	if err != nil {
		return err
	}

	destinationOauthServerDeployment.Name = hcpNameForNamespacedStandaloneResource(destinationOauthServerDeploymentNamespace, destinationOauthServerDeploymentName)

	ctrl.Log.Info("Writing Destination OAuth Deployment", "path", t.DestinationDeploymentPath)
	return writeDeploymentOnDisk(t.DestinationDeploymentPath, destinationOauthServerDeployment)
}

func createCpContext(ctx context.Context, hcp *hyperv1.HostedControlPlane, managementClusterClient client.Client) (component.ControlPlaneContext, error) {
	// TODO: is this correct way of creating the releaseProvider ?
	//  in prod the cpContext could be provided by CPO
	pullSecret := common.PullSecret(hcp.Namespace)
	if err := managementClusterClient.Get(ctx, client.ObjectKeyFromObject(pullSecret), pullSecret); err != nil {
		return component.ControlPlaneContext{}, fmt.Errorf("failed to get pull secret: %w", err)
	}
	releaseProvider := &releaseinfo.RegistryClientProvider{}
	releaseImage, err := releaseProvider.Lookup(ctx, util.HCPControlPlaneReleaseImage(hcp), pullSecret.Data[corev1.DockerConfigJsonKey])
	if err != nil {
		return component.ControlPlaneContext{}, err
	}
	imageProvider := imageprovider.New(releaseImage)

	// i think that normally these are read from env var
	// (defined on control-plane-operator deployment)
	imageProvider.ComponentImages()[util.AvailabilityProberImageName] = "quay.io/openshift-release-dev/ocp-v4.0-art-dev@sha256:33f5ba1a1979d0e247c913091ed8cdcfc4e78dba5469ed40f5053a182c30906c"
	imageProvider.ComponentImages()["socks5-proxy"] = "quay.io/openshift-release-dev/ocp-v4.0-art-dev@sha256:33f5ba1a1979d0e247c913091ed8cdcfc4e78dba5469ed40f5053a182c30906c"
	imageProvider.ComponentImages()[util.CPOImageName] = "quay.io/openshift-release-dev/ocp-v4.0-art-dev@sha256:33f5ba1a1979d0e247c913091ed8cdcfc4e78dba5469ed40f5053a182c30906c"

	return component.ControlPlaneContext{
		Context:              ctx,
		ReleaseImageProvider: imageProvider,
		HCP:                  hcp,
		Client:               managementClusterClient,
	}, nil
}

func removeSpecTemplateSpecAffinityFromDeployment(deployment *appsv1.Deployment) {
	deployment.Spec.Template.Spec.Affinity = nil
}

func removeSpecTemplateSpecNodeSelectorFromDeployment(deployment *appsv1.Deployment) {
	deployment.Spec.Template.Spec.NodeSelector = nil
}

func removeSpecTemplateSpecPriorityClassFromDeployment(deployment *appsv1.Deployment) {
	deployment.Spec.Template.Spec.PriorityClassName = ""
}

func removeSpecTemplateSpecServiceAccountNameFromDeployment(deployment *appsv1.Deployment) {
	deployment.Spec.Template.Spec.ServiceAccountName = ""
}

func removeSpecTemplateSpecTolerationsFromDeployment(deployment *appsv1.Deployment) {
	deployment.Spec.Template.Spec.Tolerations = nil
}

func removeSpecTemplateSpecMetadataAnnotationFromDeployment(deployment *appsv1.Deployment) {
	// this gives: unable to validate against any security context constraint: provider "privileged"
	delete(deployment.Spec.Template.ObjectMeta.Annotations, "openshift.io/required-scc")
}

func transformOauthServerContainerToMatchHCP(hcpOauthDeployment, destinationOauthServerDeployment *appsv1.Deployment) error {
	standaloneOauthServerContainer, err := refNamedContainerFromDeployment(destinationOauthServerDeployment, "oauth-openshift")
	if err != nil {
		return err
	}
	hcpOauthServerContainer, err := refNamedContainerFromDeployment(hcpOauthDeployment, "oauth-openshift")
	if err != nil {
		return err
	}

	// hcp doesn't expose any ports but cpy
	standaloneOauthServerContainer.Ports = hcpOauthServerContainer.Ports

	// hcp doesn't set security context but cpy
	standaloneOauthServerContainer.SecurityContext = hcpOauthServerContainer.SecurityContext

	// hcp doesn't set lifecycle but cpy
	standaloneOauthServerContainer.Lifecycle = hcpOauthServerContainer.Lifecycle

	// copy env var specified for hcp
	standaloneOauthServerContainer.Env = hcpOauthServerContainer.Env

	// values for some flags are different - align with hcp
	for _, flagToUpdate := range []string{"--audit-log-path", "--audit-log-maxbackup", "--audit-log-maxsize"} {
		for _, hcpContainerArg := range hcpOauthServerContainer.Args {
			hcpOauthAuditLogPathVal := getContainerFlagValue(hcpContainerArg, flagToUpdate)
			if len(hcpOauthAuditLogPathVal) > 0 {
				for i, standaloneContainerArg := range standaloneOauthServerContainer.Args {
					standaloneOauthAuditLogPathVal := getContainerFlagValue(standaloneContainerArg, flagToUpdate)
					if len(standaloneOauthAuditLogPathVal) > 0 {
						standaloneContainerArg = setContainerFlagValue(standaloneContainerArg, flagToUpdate, hcpOauthAuditLogPathVal)
						standaloneOauthServerContainer.Args[i] = standaloneContainerArg
						break
					}
				}
				break
			}
		}
	}

	// copy imagePullPolicy from hcp
	standaloneOauthServerContainer.ImagePullPolicy = hcpOauthServerContainer.ImagePullPolicy

	// match the liveness probe
	standaloneOauthServerContainer.LivenessProbe = hcpOauthServerContainer.LivenessProbe

	// match the readiness probe
	standaloneOauthServerContainer.ReadinessProbe = hcpOauthServerContainer.ReadinessProbe

	// match the resources
	standaloneOauthServerContainer.Resources = hcpOauthServerContainer.Resources

	// the hostPath was removed so we need to also remove the vol mount
	removeVolumeMountFromContainer(standaloneOauthServerContainer, "audit-dir")
	removeVolumeMountFromContainer(standaloneOauthServerContainer, "v4-0-config-system-router-certs")

	// match hcp on the msg policy
	standaloneOauthServerContainer.TerminationMessagePolicy = hcpOauthServerContainer.TerminationMessagePolicy

	// hcp has a different strategy for "exposing" the audit logs
	addVolumeMountToContainer(standaloneOauthServerContainer, "logs", "/var/run/kubernetes")

	// the oauth-server on hcp uses the kubeconfig in the osin config thus we need to mount it
	addVolumeMountToContainer(standaloneOauthServerContainer, "kubeconfig", "/etc/kubernetes/secrets/kubeconfig")

	return nil
}

func copyAuditLogsContainerFromHCPOauthDeployment(hcpOauthDeployment, destinationOauthServerDeployment *appsv1.Deployment) error {
	hcpAuditLogsContainer, err := refNamedContainerFromDeployment(hcpOauthDeployment, "audit-logs")
	if err != nil {
		return err
	}

	destinationOauthServerDeployment.Spec.Template.Spec.Containers = append(destinationOauthServerDeployment.Spec.Template.Spec.Containers, *hcpAuditLogsContainer)
	return nil
}

func copyNamespaceFromHCPOauthDeployment(hcpOauthDeployment, destinationOauthServerDeployment *appsv1.Deployment) {
	destinationOauthServerDeployment.Namespace = hcpOauthDeployment.Namespace
	destinationOauthServerDeployment.Spec.Template.Namespace = hcpOauthDeployment.Spec.Template.Namespace
}

func copySpecRevisionHistoryLimitFromHCPOauthDeployment(hcpOauthDeployment, destinationOauthServerDeployment *appsv1.Deployment) {
	destinationOauthServerDeployment.Spec.RevisionHistoryLimit = hcpOauthDeployment.Spec.RevisionHistoryLimit
}

func copySpecTemplateSpecTerminationGracePeriodSecondsFromHCPOauthDeployment(hcpOauthDeployment, destinationOauthServerDeployment *appsv1.Deployment) {
	destinationOauthServerDeployment.Spec.Template.Spec.TerminationGracePeriodSeconds = hcpOauthDeployment.Spec.Template.Spec.TerminationGracePeriodSeconds
}

func copySpecStrategyFromHCPOauthDeployment(hcpOauthDeployment, destinationOauthServerDeployment *appsv1.Deployment) {
	destinationOauthServerDeployment.Spec.Strategy = hcpOauthDeployment.Spec.Strategy
}

func refNamedContainerFromDeployment(deployment *appsv1.Deployment, containerName string) (*corev1.Container, error) {
	for i, _ := range deployment.Spec.Template.Spec.Containers {
		if deployment.Spec.Template.Spec.Containers[i].Name == containerName {
			return &deployment.Spec.Template.Spec.Containers[i], nil
		}
	}
	return nil, fmt.Errorf("container %s not found in %s/%s deployment", containerName, deployment.Namespace, deployment.Name)
}

func renameConfigMapReferenceInSpecTemplateSpecVolumesFromDeployment(deployment *appsv1.Deployment, oldName, newName string) {
	for i := range deployment.Spec.Template.Spec.Volumes {
		vol := &deployment.Spec.Template.Spec.Volumes[i]
		if vol.ConfigMap != nil && vol.ConfigMap.Name == oldName {
			vol.ConfigMap.Name = newName
		}
	}
}

func renameSecretReferenceInSpecTemplateSpecVolumesFromDeployment(deployment *appsv1.Deployment, oldName, newName string) {
	for i := range deployment.Spec.Template.Spec.Volumes {
		vol := &deployment.Spec.Template.Spec.Volumes[i]
		if vol.Secret != nil && vol.Secret.SecretName == oldName {
			vol.Secret.SecretName = newName
		}
	}
}

func removeNamedVolumeFromSpecTemplateSpecVolumesFromDeployment(deployment *appsv1.Deployment, volumeName string) {
	var volumes []corev1.Volume

	for i := range deployment.Spec.Template.Spec.Volumes {
		vol := deployment.Spec.Template.Spec.Volumes[i]
		if vol.Name == volumeName {
			continue
		}
		volumes = append(volumes, vol)
	}

	deployment.Spec.Template.Spec.Volumes = volumes
}

func removeVolumeMountFromContainer(container *corev1.Container, volumeMountName string) {
	var mounts []corev1.VolumeMount
	for _, mount := range container.VolumeMounts {
		if mount.Name == volumeMountName {
			continue
		}
		mounts = append(mounts, mount)
	}
	container.VolumeMounts = mounts
}

var containerFlagValueRegExpFmtStr = `(?m)(%s)=([^\s]+)`

func getContainerFlagValue(text, flag string) string {
	containerFlagValueRegExp := regexp.MustCompile(fmt.Sprintf(containerFlagValueRegExpFmtStr, flag))
	matches := containerFlagValueRegExp.FindStringSubmatch(text)

	if len(matches) > 2 {
		return matches[2]
	}
	return ""
}

func setContainerFlagValue(text, flag, newValue string) string {
	containerFlagValueRegExp := regexp.MustCompile(fmt.Sprintf(containerFlagValueRegExpFmtStr, flag))

	if containerFlagValueRegExp.MatchString(text) {
		return containerFlagValueRegExp.ReplaceAllString(text, fmt.Sprintf("${1}=%s", newValue))
	}

	return text
}

func addVolumeMountToContainer(container *corev1.Container, mountName, mountPath string) {
	for _, vm := range container.VolumeMounts {
		if vm.Name == mountName {
			return
		}
	}

	newMount := corev1.VolumeMount{
		Name:      mountName,
		MountPath: mountPath,
	}

	container.VolumeMounts = append(container.VolumeMounts, newMount)
}

func copyNamedSpecTemplateSpecVolumeFromHCP(hcpOauthDeployment, destinationOauthServerDeployment *appsv1.Deployment, volumeName string) {
	var hcpNamedVol *corev1.Volume
	for i, vol := range hcpOauthDeployment.Spec.Template.Spec.Volumes {
		if vol.Name == volumeName {
			hcpNamedVol = &hcpOauthDeployment.Spec.Template.Spec.Volumes[i]
			break
		}
	}

	if hcpNamedVol == nil {
		return
	}

	for _, vol := range destinationOauthServerDeployment.Spec.Template.Spec.Volumes {
		if vol.Name == volumeName {
			return
		}
	}

	copied := *hcpNamedVol
	destinationOauthServerDeployment.Spec.Template.Spec.Volumes = append(destinationOauthServerDeployment.Spec.Template.Spec.Volumes, copied)
}

func writeDeploymentOnDisk(path string, destination *appsv1.Deployment) error {
	deploymentBytes, err := yaml.Marshal(destination)
	if err != nil {
		return err
	}

	return os.WriteFile(path, deploymentBytes, 0644)
}

func readOauthServerDeployment(path string) (*appsv1.Deployment, error) {
	deploymentBytes, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("read file err: %w", err)
	}

	return resourceread.ReadDeploymentV1OrDie(deploymentBytes), nil
}
