package deepcopy

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/openshift/api/tools/codegen/pkg/utils"
	"k8s.io/gengo/args"
	"k8s.io/gengo/examples/deepcopy-gen/generators"
	"k8s.io/klog/v2"
)

// generateDeepcopyFunctions generates the DeepCopy functions for the given API package paths.
func generateDeepcopyFunctions(path, packagePath, outputBaseFileName, headerFilePath string, verify bool) error {
	wd, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("failed to get working directory: %w", err)
	}

	// The deepcopy generator cannot import from an absolute path.
	inputPath, err := filepath.Rel(wd, path)
	if err != nil {
		return fmt.Errorf("failed to get relative path for %s: %w", path, err)
	}
	// The path must start with `./` to be considered a relative path
	// by the generator.
	inputPath = fmt.Sprintf(".%s%s", string(os.PathSeparator), inputPath)

	pathPrefix, err := utils.GetPathPrefix(wd, inputPath, packagePath)
	if err != nil {
		return fmt.Errorf("failed to get path prefix: %w", err)
	}

	arguments := args.GeneratorArgs{
		InputDirs:                  []string{inputPath},
		OutputFileBaseName:         outputBaseFileName,
		TrimPathPrefix:             pathPrefix,
		GeneratedBuildTag:          "ignore_autogenerated",
		GeneratedByCommentTemplate: "// Code generated by deepcopy-gen. DO NOT EDIT.",
		GoHeaderFilePath:           headerFilePath,
		VerifyOnly:                 verify,
	}

	klog.V(2).Infof("Generating deepcopy into %s", filepath.Join(wd, strings.TrimPrefix(packagePath, pathPrefix)))

	if err := arguments.Execute(
		generators.NameSystems(),
		generators.DefaultNameSystem(),
		generators.Packages,
	); err != nil {
		return fmt.Errorf("error executing deepcopy generator: %w", err)
	}

	return nil
}
